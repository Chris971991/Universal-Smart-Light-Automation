blueprint:
  name: Universal Smart Presence Lighting Control - Enhanced v3.8.7
  description: >
    # Universal Smart Presence Lighting Control - Enhanced Version 3.8.7
    
    Intelligently manages your lighting based on room occupancy, light levels, and manual controls.
    Works perfectly for ANY room - bedrooms, offices, living rooms, kitchens, bathrooms, etc.
    
    ---
    
    ## ðŸ”„ Automatic Update Notifications (Optional)
    
    Get notified when new blueprint versions are available! To enable this feature:
    
    **Step 1:** Add this sensor to your configuration.yaml file:
    
    ```yaml
    sensor:
      - platform: rest
        name: "Universal Lighting Updates"
        resource: https://api.github.com/repos/Chris971991/universal-smart-light-automation/releases/latest
        value_template: >
          {{ '{{' }} value_json.tag_name | default('unknown') {{ '}}' }}
        scan_interval: 86400
    ```
    
    **Step 2:** Restart Home Assistant
    
    **Step 3:** Enable the "Check for Updates" option at the bottom of this configuration
    
    ## ðŸŽ¯ UNIVERSAL DESIGN
    
    This single blueprint works for ALL room types:
    â€¢ **Bedrooms** - Full bed sensor integration with WORKING delays (v3.8.7)
    â€¢ **Living Areas** - Standard presence-based control
    â€¢ **Offices** - Productivity-focused lighting
    â€¢ **Any Room** - Fully customizable behavior
    
    ## FIXED IN v3.8.7: Universal Compatibility
    
    â€¢ **No More Setup Errors** - Works with or without bed sensor configured
    
    â€¢ **Smart Bed Detection** - Automatically detects bed state changes every 5 seconds
    
    â€¢ **True Universal Blueprint** - One blueprint for ALL rooms, no errors!
    
    ## FIXED IN v3.8.6: Bed Sensor Delays Actually Work!
    
    â€¢ **Entry Delay** - Properly waits X seconds after getting into bed before turning lights off
    
    â€¢ **Exit Delay** - Properly waits X seconds after getting out of bed before turning lights on
    
    â€¢ **Simple & Robust** - No complex state tracking, just simple delays that work
    
    ## FIXED IN v3.8.5: Accurate Sunrise/Sunset
    
    â€¢ **Time-Based Calculation** - Uses actual sunrise/sunset times with proper offset handling
    
    â€¢ **Precise Offsets** - Your +30/-30 minute settings now work exactly as expected
    
    â€¢ **All Latitudes** - Works accurately everywhere, from equator to polar regions
    
    ## IMPROVED IN v3.8.3: Smart Logging Control
    
    â€¢ **Smart Logging** - Error logs always visible for critical issues
    
    â€¢ **Clean Multi-Room** - Debug logs only show for rooms you're troubleshooting
    
    â€¢ **Better Performance** - Reduced log overhead when not debugging
    
    ## ENHANCED IN v3.8.2: Simplified Daytime Control
    
    â€¢ **Unified Daytime Mode** - Single setting replaces redundant Away/No-Daytime options
    
    â€¢ **Three Clear Choices** - Always Allow, Block When Away, or Always Block
    
    â€¢ **Smarter Configuration** - Cleaner, more intuitive settings
    
    For full version history and documentation, visit:
    https://github.com/Chris971991/universal-smart-light-automation

    ## Features

    â€¢ **Automatic Control** - Turns lights on when dark and someone is present
    
    â€¢ **Energy Saving** - Turns lights off when room is vacant
    
    â€¢ **Smart Overrides** - Respects when you manually control lights
    
    â€¢ **Daytime Control** - Flexible options for daytime lighting behavior
    
    â€¢ **Bright Room Logic** - Clears overrides when turning off lights in well-lit rooms
    
    â€¢ **Timeout Protection** - Clears overrides after configurable timeout
    
    â€¢ **Vacancy Override** - Optional: Clear overrides after extended vacancy
    
    â€¢ **Adaptive Brightness** - Optional brightness adjustment based on time and ambient light
    
    â€¢ **Color Temperature Control** - Optional color temperature adjustment throughout the day
    
    â€¢ **Advanced Dimming** - Independent fade in/out control with separate timing
    
    â€¢ **Illuminance Averaging** - Prevents light flapping from momentary light changes
    
    â€¢ **Guest Mode** - Special behavior for when you have guests
    
    â€¢ **Human-Friendly** - Lights stay on while room is occupied, regardless of brightness
    
    â€¢ **Smart Bedroom Support** - Bed sensor with WORKING delays (fixed in v3.8.6)
    
    â€¢ **Bedtime Auto-Off** - Automatically turn lights off after delay when getting into bed

    ## Compatible Sensors

    This blueprint works with:
    â€¢ Everything Presence One/Light sensors
    â€¢ Standard motion/PIR sensors
    â€¢ mmWave/radar presence sensors
    â€¢ Any illuminance/light level sensor
    â€¢ Bed occupancy sensors (optional for bedrooms)
    â€¢ Phone/device trackers for home presence
    â€¢ Or combinations of these sensors
    
    ## REQUIRED HELPER ENTITIES

    Before using this blueprint, you MUST create these helper entities.
    
    **IMPORTANT**: All entity IDs must be lowercase! If your room name is "Office", 
    the helpers should use "office" (lowercase) in their entity IDs.
    
    1. `input_boolean.[room_name]_automation_active`
       - Tracks when automation is running an action
       - Example: input_boolean.office_automation_active
    
    2. `input_boolean.[room_name]_manual_override`
       - Tracks when user has manually overridden automation
       - Example: input_boolean.office_manual_override
    
    3. `input_boolean.[room_name]_light_auto_on`
       - Tracks if light was automatically turned on
       - Example: input_boolean.office_light_auto_on
    
    4. `input_datetime.[room_name]_last_automation_action`
       - Stores timestamp of last automation action
       - MUST have both date AND time enabled
       - Example: input_datetime.office_last_automation_action
    
    5. `input_boolean.[room_name]_occupancy_state`
       - Tracks combined occupancy state from all sensors
       - Example: input_boolean.office_occupancy_state
    
    6. `input_text.[room_name]_illuminance_history`
       - Stores recent illuminance readings for averaging
       - Example: input_text.office_illuminance_history
    
    Replace [room_name] with your actual room name in LOWERCASE (e.g., office, bedroom, living_room)
    
    ## Daytime Control Modes
    
    **Always Allow**: Normal operation - lights turn on automatically when dark and occupied
    
    **Block When Away**: Energy saving mode - prevents automatic turn-on during daytime when nobody's home
    
    **Always Block**: Maximum energy saving - never turn on automatically during daytime hours
    
    All modes still allow:
    â€¢ Manual control at any time
    â€¢ Automatic turn-OFF for energy saving
    â€¢ Nighttime operation
    
    ## Guest Mode
    
    When enabled, guest mode modifies the automation behavior to be more guest-friendly:
    - Lights stay on longer when room is vacant
    - Manual overrides last longer before timing out
    - Less aggressive power saving
    - More forgiving presence detection
    - Bed occupancy features can be temporarily disabled (for bedrooms)
    
    Perfect for when you have visitors, parties, or service workers in your home.

  domain: automation
  input:
    room_name:
      name: Room Name
      description: >
        Name of the room used throughout the automation for entity naming and logging.
        You can use any capitalization here (e.g., "Office", "Living Room"), but note that
        all helper entity IDs will be created in lowercase. For example, if you enter "Office",
        the helpers should be created as "input_boolean.office_automation_active", etc.
        Use underscores instead of spaces for multi-word names (e.g., "living_room").
      selector:
        text:
    presence_pir_sensor:
      name: PIR Motion Sensor
      description: >
        Motion sensor that detects immediate movement. This can be any PIR/motion sensor.
        For Everything Presence devices, use binary_sensor.everything_presence_xxx_pir.
        For standard motion sensors, use your motion sensor entity.
      selector:
        entity:
          domain: binary_sensor
          device_class: 
            - motion
            - occupancy
            - presence
    presence_mmwave_sensor:
      name: Occupancy Sensor (Optional)
      description: >
        Secondary occupancy sensor that can detect presence even without movement.
        If you only have one motion sensor, you can select the same entity again.
        For Everything Presence devices, use binary_sensor.everything_presence_xxx_occupancy.
        For mmWave/radar sensors, use your occupancy entity.
      default: ""
      selector:
        entity:
          domain: binary_sensor
          device_class: 
            - motion
            - occupancy
            - presence
    illuminance_sensor:
      name: Illuminance Sensor
      description: >
        Sensor that measures room brightness in lux (lumens per square meter).
        For Everything Presence devices, use sensor.everything_presence_xxx_illuminance.
        For other light sensors, select any sensor that provides light level readings.
        If you don't have a light sensor, create an input_number helper set to 50 lux.
      selector:
        entity:
          domain: 
            - sensor
            - input_number
    light_switch:
      name: Light Switch/Entity (Optional - see Light Entities below)
      description: >
        **OPTIONAL** - The switch that controls your lights.
        
        â€¢ **For smart switch + smart lights**: Select your wall switch here. The switch acts as a controller - physical presses send commands to control the smart lights (doesn't cut power).
        
        â€¢ **For smart lights only**: Leave this empty and use the Light Entities field below.
        
        â€¢ **For smart switch only (dumb lights)**: Select your smart switch here and leave Light Entities empty.
        
        Works with both switch.* entities (simple on/off) and light.* entities (supports brightness).
      default: ""
      selector:
        entity:
          domain: [switch, light]
    light_entities:
      name: Light Entities (Optional - for smart lights)
      description: >
        **OPTIONAL** - Select your smart light entities here.
        
        â€¢ **For smart lights**: Select one or more light entities to control directly.
        
        â€¢ **For smart switch + smart lights**: Select your smart lights here. The switch acts as a controller for these lights.
        
        â€¢ **For smart switch only**: Leave this empty.
        
        All light-specific features (brightness, color temperature, dimming) will be applied to these entities.
      default: []
      selector:
        entity:
          domain: light
          multiple: true
    control_mode:
      name: Control Mode
      description: >
        Select how your lighting is set up:
        
        **Smart Switch + Smart Lights** - You have a wall switch AND smart bulbs. The switch acts as a controller - pressing it sends commands to toggle the smart lights (doesn't cut power).
        
        **Smart Lights Only** - You only have smart bulbs with no separate switch (e.g., lamps, integrated fixtures).
        
        **Smart Switch Only** - You have a smart switch controlling regular (non-smart) bulbs.
      default: "switch_only"
      selector:
        select:
          options:
            - label: "Smart Switch + Smart Lights"
              value: "switch_and_lights"
            - label: "Smart Lights Only"
              value: "lights_only"
            - label: "Smart Switch Only"
              value: "switch_only"
    daytime_control_mode:
      name: Daytime Lighting Control
      description: >
        How should automatic lighting work during daytime hours?
        
        **Always Allow** - Normal operation, lights turn on automatically when dark and occupied
        
        **Block When Away** - Energy saving mode - prevents auto-on during daytime when nobody's home
        (Requires phone/device trackers to be configured below)
        
        **Always Block** - Maximum energy saving - never auto-on during daytime regardless of presence
        (Perfect for rooms with good natural light)
        
        Note: Manual control and automatic turn-OFF always work regardless of this setting.
      default: "always_allow"
      selector:
        select:
          options:
            - label: "Always Allow - Normal operation"
              value: "always_allow"
            - label: "Block When Away - Save energy when gone"
              value: "block_when_away"
            - label: "Always Block - No daytime auto-on"
              value: "always_block"
    presence_trackers:
      name: Family Phones/Device Trackers (For "Block When Away" Mode)
      description: >
        **REQUIRED if using "Block When Away" mode** - Select all family member phones or device trackers.
        
        The automation considers someone home if ANY of these devices are home.
        
        Examples:
        â€¢ device_tracker.johns_iphone
        â€¢ device_tracker.janes_android
        â€¢ device_tracker.kids_phone
        
        You can also use other trackers like car trackers, smart watches, etc.
        
        Leave empty if using "Always Allow" or "Always Block" modes.
      default: []
      selector:
        entity:
          domain: device_tracker
          multiple: true
    sunrise_offset_minutes:
      name: Sunrise Offset (minutes)
      description: >
        Minutes to add/subtract from sunrise to define start of "daytime".
        
        â€¢ **Positive values** (+30) = Daytime starts AFTER sunrise
        â€¢ **Negative values** (-30) = Daytime starts BEFORE sunrise
        â€¢ **Recommended**: +30 (daytime starts 30 min after sunrise when it's bright)
        
        This affects "Block When Away" and "Always Block" modes.
      default: 30
      selector:
        number:
          min: -120
          max: 120
          unit_of_measurement: min
          mode: slider
          step: 5
    sunset_offset_minutes:
      name: Sunset Offset (minutes)
      description: >
        Minutes to add/subtract from sunset to define end of "daytime".
        
        â€¢ **Positive values** (+30) = Daytime ends AFTER sunset
        â€¢ **Negative values** (-30) = Daytime ends BEFORE sunset
        â€¢ **Recommended**: -30 (daytime ends 30 min before sunset while still light)
        
        This affects "Block When Away" and "Always Block" modes.
      default: -30
      selector:
        number:
          min: -120
          max: 120
          unit_of_measurement: min
          mode: slider
          step: 5
    bed_occupied_helper:
      name: Bed Sensor (Optional - For Bedrooms Only)
      description: >
        **OPTIONAL - BEDROOM FEATURE**
        
        For bedrooms only. Select your bed occupancy sensor if you have one.
        This can be either a binary_sensor (like a bed presence sensor) or an input_boolean helper.
        
        When this sensor is ON:
        â€¢ Automatic lights will NOT turn on (prevents lights when in bed)
        â€¢ Lights will turn OFF after your configured entry delay
        
        **Leave empty for non-bedroom spaces** - the automation works perfectly without it!
        
        Examples: 
        - binary_sensor.bed_presence_sensor_master_bedroom
        - input_boolean.master_bedroom_bed_occupied
      default: ""
      selector:
        entity:
          domain: 
            - binary_sensor
            - input_boolean
    turn_off_when_bed_occupied:
      name: Turn Off Lights When Getting Into Bed (Bedroom Feature)
      description: >
        **BEDROOM FEATURE** - Only applies if bed sensor is configured above.
        
        When enabled, lights will automatically turn OFF after the entry delay when getting into bed.
        This is perfect for bedtime - the lights turn off once you're settled in bed.
        
        When disabled, bed occupancy only prevents lights from turning ON automatically.
        
        Has no effect if no bed sensor is configured.
      default: true
      selector:
        boolean:
    bed_entry_delay_seconds:
      name: Bed Entry Delay (seconds)
      description: >
        **BEDROOM FEATURE** - Only applies if bed sensor is configured.
        
        How long to wait after bed sensor detects occupancy before turning lights OFF.
        This prevents lights turning off when you just sit on the bed temporarily.
        
        Examples:
        â€¢ 10 seconds - Quick response for immediate bedtime
        â€¢ 30 seconds - Balanced for most users
        â€¢ 60 seconds - Conservative, ensures you're staying in bed
        
        Set to 0 for immediate response (not recommended).
      default: 30
      selector:
        number:
          min: 0
          max: 300
          unit_of_measurement: sec
          mode: slider
          step: 5
    bed_exit_delay_seconds:
      name: Bed Exit Delay (seconds)
      description: >
        **BEDROOM FEATURE** - Only applies if bed sensor is configured.
        
        How long to wait after bed sensor shows unoccupied before allowing lights to turn ON.
        This prevents lights turning on when you roll over or briefly lose sensor contact.
        
        Examples:
        â€¢ 5 seconds - Quick response for getting up
        â€¢ 15 seconds - Balanced for most users
        â€¢ 30 seconds - Conservative, prevents false triggers from movement
        
        Set to 0 for immediate response (may cause false triggers).
      default: 15
      selector:
        number:
          min: 0
          max: 120
          unit_of_measurement: sec
          mode: slider
          step: 5
    dark_threshold:
      name: Dark Threshold
      description: >
        Lux threshold below which the room is considered dark enough to need lights.
        When illuminance falls below this value AND someone is present, lights will
        turn on automatically. Typically 20-50 lux for most rooms.
        MUST be lower than bright threshold!
      default: 30
      selector:
        number:
          min: 0
          max: 499
          unit_of_measurement: lux
          mode: slider
          step: 1
    bright_threshold:
      name: Bright Threshold
      description: >
        Lux threshold above which the room is considered bright (has enough natural light).
        This threshold is important for the "clear override when turning off lights in bright room"
        feature. When you manually turn off lights in a bright room, the override is cleared.
        Usually 150-300 lux is appropriate for most rooms.
        MUST be higher than dark threshold!
      default: 200
      selector:
        number:
          min: 1
          max: 500
          unit_of_measurement: lux
          mode: slider
          step: 1
    extremely_dark_threshold:
      name: Extremely Dark Threshold
      description: >
        Lux threshold below which the room is considered extremely dark (pitch black).
        This allows for more aggressive light control in very dark conditions.
        Usually 1-5 lux for complete darkness.
      default: 3
      selector:
        number:
          min: 0
          max: 20
          unit_of_measurement: lux
          mode: slider
          step: 0.1
    sensor_off_latency_entity:
      name: Sensor Off Latency Entity (Optional)
      description: >
        Entity that provides the sensor's off latency/timeout value in seconds.
        For Everything Presence devices, use number.everything_presence_xxx_occupancy_off_latency.
        For other sensors, leave this blank and use the fixed value below.
      default: ""
      selector:
        entity:
          domain: number
          multiple: false
    fixed_latency_seconds:
      name: Fixed Off Latency (seconds)
      description: >
        Fixed off latency value in seconds, used if sensor_off_latency_entity is not available.
        This is how long after the last detected motion before the sensor reports "no presence".
        Typically 30-120 seconds is appropriate, with 60 being a good default.
      default: 60
      selector:
        number:
          min: 10
          max: 300
          unit_of_measurement: sec
          mode: slider
          step: 10
    vacancy_timeout_multiplier:
      name: Vacancy Timeout Multiplier
      description: >
        Multiplier applied to the sensor off latency to determine true vacancy.
        For example, with a 60s latency and 5Ã— multiplier = 5 minute vacancy timeout.
        Higher values prevent false offs but delay automatic actions.
      default: 5
      selector:
        number:
          min: 1
          max: 30
          mode: slider
          step: 1
    override_behavior:
      name: Override Behavior
      description: >
        Choose how manual overrides should be handled:
        
        **Timeout Only** - Manual overrides are respected until the timeout expires. 
        This gives you complete control - the room could be vacant for hours and your 
        manual choice will be respected.
        
        **Vacancy Can Clear** - Manual overrides can be cleared by extended vacancy.
        This prevents forgotten overrides from keeping lights off when you return to
        a dark room hours later. More convenient but less absolute control.
      default: "timeout_only"
      selector:
        select:
          options:
            - label: "Timeout Only - Full manual control"
              value: "timeout_only"
            - label: "Vacancy Can Clear - Smarter but less control"
              value: "vacancy_clear"
    vacancy_clear_minutes:
      name: Vacancy Clear Time (minutes)
      description: >
        When using "Vacancy Can Clear" mode, how many minutes of vacancy before clearing overrides.
        This is separate from the normal vacancy timeout - it's specifically for clearing manual overrides.
        Typically 30-60 minutes to ensure the room is truly abandoned.
        Only applies when Override Behavior is set to "Vacancy Can Clear".
      default: 45
      selector:
        number:
          min: 10
          max: 120
          unit_of_measurement: min
          mode: slider
          step: 5
    override_timeout_hours:
      name: Override Timeout Hours
      description: >
        Maximum hours a manual override will remain active before being automatically cleared.
        This ensures forgotten overrides don't permanently disable automation.
        Typical values are 2-4 hours for most rooms.
      default: 3
      selector:
        number:
          min: 1
          max: 24
          unit_of_measurement: hours
          mode: slider
          step: 0.5
    override_respect_presence:
      name: Respect Presence for Override Timeout
      description: >
        When enabled, manual override timeout will NOT clear while you're still in the room.
        The override will only clear when:
        â€¢ You leave the room (vacancy clear)
        â€¢ You manually control the lights again
        â€¢ The timeout expires AND the room is vacant
        
        This prevents lights from suddenly turning on after the timeout if you're still 
        present and had manually turned them off.
        
        Example: You manually turn lights off to watch a movie. With this enabled, the 
        lights won't suddenly turn on 3 hours later if you're still watching.
      default: true
      selector:
        boolean:
    enable_adaptive_brightness:
      name: Enable Adaptive Brightness
      description: >
        When enabled, automatically adjusts light brightness based on time of day and ambient light.
        Only works with light.* entities that support brightness control.
        Brightness will be lower at night and higher during the day.
      default: true
      selector:
        boolean:
    enable_color_temperature:
      name: Enable Color Temperature Control
      description: >
        When enabled, automatically adjusts the color temperature of lights throughout the day.
        Cool white during daytime for alertness, warm white in evening for relaxation.
        Only works with lights that support color temperature control.
      default: true
      selector:
        boolean:
    day_color_temp:
      name: Daytime Color Temperature
      description: >
        Color temperature for daytime hours (9 AM - 5 PM).
        Higher values = cooler/bluer light for alertness.
        Typical range: 4000-6500K
      default: 5000
      selector:
        number:
          min: 2700
          max: 6500
          unit_of_measurement: K
          mode: slider
          step: 100
    night_color_temp:
      name: Nighttime Color Temperature
      description: >
        Color temperature for nighttime hours.
        Lower values = warmer/orange light for relaxation.
        Typical range: 2700-3500K
      default: 3000
      selector:
        number:
          min: 2700
          max: 6500
          unit_of_measurement: K
          mode: slider
          step: 100
    enable_fade_on:
      name: Enable Fade On
      description: >
        When enabled, lights will fade in smoothly when turning on.
        When disabled, lights will turn on instantly to the target brightness.
        Only works with light entities that support transitions.
      default: true
      selector:
        boolean:
    fade_on_time:
      name: Fade On Time (seconds)
      description: >
        How long the fade in should take when turning lights on.
        Only applies if fade on is enabled and the light supports transitions.
      default: 1.5
      selector:
        number:
          min: 0.5
          max: 10
          unit_of_measurement: sec
          mode: slider
          step: 0.5
    enable_fade_off:
      name: Enable Fade Off
      description: >
        When enabled, lights will fade out smoothly when turning off.
        When disabled, lights will turn off instantly.
        Only works with light entities that support transitions.
      default: true
      selector:
        boolean:
    fade_off_time:
      name: Fade Off Time (seconds)
      description: >
        How long the fade out should take when turning lights off.
        Only applies if fade off is enabled and the light supports transitions.
      default: 2.0
      selector:
        number:
          min: 0.5
          max: 10
          unit_of_measurement: sec
          mode: slider
          step: 0.5
    enable_illuminance_averaging:
      name: Enable Illuminance Averaging
      description: >
        When enabled, averages the last 5 light readings to prevent flapping.
        Helps when clouds, shadows, or sensor noise cause rapid light changes.
        Adds stability but slightly delays response to legitimate lighting changes.
      default: true
      selector:
        boolean:
    enable_guest_mode:
      name: Enable Guest Mode
      description: >
        When enabled, the automation becomes more guest-friendly:
        â€¢ Lights stay on longer when vacant
        â€¢ Manual overrides last longer
        â€¢ Less aggressive power saving
        â€¢ More forgiving presence detection
        â€¢ Bed occupancy features can be disabled (for bedrooms)
        
        Perfect for visitors, parties, or service workers.
      default: false
      selector:
        boolean:
    guest_vacancy_multiplier:
      name: Guest Mode - Vacancy Multiplier
      description: >
        In guest mode, how much longer to wait before turning off lights.
        2.0 = twice as long, 3.0 = three times as long, etc.
        Only applies when guest mode is enabled.
      default: 2.5
      selector:
        number:
          min: 1.5
          max: 5.0
          mode: slider
          step: 0.5
    guest_override_multiplier:
      name: Guest Mode - Override Timeout Multiplier
      description: >
        In guest mode, how much longer manual overrides remain active.
        2.0 = twice as long, 3.0 = three times as long, etc.
        Only applies when guest mode is enabled.
      default: 2.0
      selector:
        number:
          min: 1.5
          max: 5.0
          mode: slider
          step: 0.5
    guest_ignore_bed:
      name: Guest Mode - Ignore Bed Sensor (Bedroom Feature)
      description: >
        **BEDROOM FEATURE** - Only applies if bed sensor is configured.
        
        When enabled, bed occupancy is ignored in guest mode.
        Useful when guests are using the bedroom and you don't want
        the bed sensor to affect lighting.
        
        Has no effect if no bed sensor is configured.
      default: true
      selector:
        boolean:
    enable_debug_logs:
      name: Enable Debug Logs
      description: >
        Enable detailed debug logging in Home Assistant. These logs help understand
        the automation's decisions and troubleshoot issues.
        View logs in Settings â†’ System â†’ Logs, filtered for your room name.
        
        NOTE: Error logs are always shown for critical issues regardless of this setting.
      default: false
      selector:
        boolean:
    enable_update_check:
      name: "ðŸ”„ Check for Updates"
      description: >
        Enable this AFTER completing the setup steps shown at the top of this blueprint.
        
        If the sensor is configured correctly, you'll receive notifications when updates are available.
        If not configured, this option does nothing (but won't cause any errors).
      default: false
      selector:
        boolean:

# Variables and state management - SIMPLIFIED v3.8.7 with universal bed handling
variables:
  # Store start time for performance monitoring
  start_time: "{{ now().timestamp() }}"
  
  # Version checking
  blueprint_version: "3.8.7"  # UPDATE THIS WITH EACH RELEASE
  enable_update_check: !input enable_update_check
  update_sensor: "sensor.universal_lighting_updates"
  
  # Check if sensor exists and has data
  sensor_exists: >-
    {{ states(update_sensor) not in ['unknown', 'unavailable', None] }}
  
  # Get latest version safely
  latest_version: >-
    {% if sensor_exists %}
      {{ states(update_sensor) | replace('v', '') | replace('V', '') }}
    {% else %}
      {{ blueprint_version }}
    {% endif %}
  
  # Check if update available
  update_available: >-
    {% if enable_update_check and sensor_exists %}
      {% set current = blueprint_version | replace('v', '') | replace('V', '') %}
      {% set latest = latest_version %}
      {% if current != latest %}
        {% set current_parts = current.split('.') | map('int', 0) | list %}
        {% set latest_parts = latest.split('.') | map('int', 0) | list %}
        {% if latest_parts[0] > current_parts[0] %}
          true
        {% elif latest_parts[0] == current_parts[0] and latest_parts[1] | default(0) > current_parts[1] | default(0) %}
          true
        {% elif latest_parts[0] == current_parts[0] and latest_parts[1] | default(0) == current_parts[1] | default(0) and latest_parts[2] | default(0) > current_parts[2] | default(0) %}
          true
        {% else %}
          false
        {% endif %}
      {% else %}
        false
      {% endif %}
    {% else %}
      false
    {% endif %}
  
  # Get release info if available
  release_name: >-
    {% if sensor_exists %}
      {{ state_attr(update_sensor, 'name') | default('New Version Available') }}
    {% else %}
      ""
    {% endif %}
  
  release_url: >-
    {% if sensor_exists %}
      {{ state_attr(update_sensor, 'html_url') | default('https://github.com/Chris971991/universal-smart-light-automation/releases/latest') }}
    {% else %}
      ""
    {% endif %}
  
  # Input variables
  room_name: !input room_name
  presence_pir_sensor: !input presence_pir_sensor
  presence_mmwave_sensor: !input presence_mmwave_sensor
  illuminance_sensor: !input illuminance_sensor
  light_switch: !input light_switch
  light_entities: !input light_entities
  control_mode: !input control_mode
  daytime_control_mode: !input daytime_control_mode
  presence_trackers: !input presence_trackers
  sunrise_offset_minutes: !input sunrise_offset_minutes
  sunset_offset_minutes: !input sunset_offset_minutes
  bed_occupied_helper: !input bed_occupied_helper
  turn_off_when_bed_occupied: !input turn_off_when_bed_occupied
  bed_entry_delay_seconds: !input bed_entry_delay_seconds
  bed_exit_delay_seconds: !input bed_exit_delay_seconds
  dark_threshold: !input dark_threshold
  bright_threshold: !input bright_threshold
  extremely_dark_threshold: !input extremely_dark_threshold
  override_timeout_hours: !input override_timeout_hours
  override_respect_presence: !input override_respect_presence
  enable_debug_logs: !input enable_debug_logs
  sensor_off_latency_entity: !input sensor_off_latency_entity
  fixed_latency_seconds: !input fixed_latency_seconds
  vacancy_timeout_multiplier: !input vacancy_timeout_multiplier
  enable_adaptive_brightness: !input enable_adaptive_brightness
  enable_color_temperature: !input enable_color_temperature
  day_color_temp: !input day_color_temp
  night_color_temp: !input night_color_temp
  enable_fade_on: !input enable_fade_on
  fade_on_time: !input fade_on_time
  enable_fade_off: !input enable_fade_off
  fade_off_time: !input fade_off_time
  override_behavior: !input override_behavior
  vacancy_clear_minutes: !input vacancy_clear_minutes
  enable_illuminance_averaging: !input enable_illuminance_averaging
  enable_guest_mode: !input enable_guest_mode
  guest_vacancy_multiplier: !input guest_vacancy_multiplier
  guest_override_multiplier: !input guest_override_multiplier
  guest_ignore_bed: !input guest_ignore_bed
  
  # Determine control entities based on mode
  has_switch: "{{ light_switch != '' and light_switch is not none }}"
  has_lights: "{{ light_entities | length > 0 }}"
  has_bed_sensor: "{{ bed_occupied_helper != '' and bed_occupied_helper is not none }}"
  has_presence_trackers: "{{ presence_trackers | length > 0 }}"
  
  # Check if trackers are required but missing
  trackers_required: "{{ daytime_control_mode == 'block_when_away' }}"
  trackers_missing: "{{ trackers_required and not has_presence_trackers }}"
  
  # FIXED v3.8.5: Accurate sunrise/sunset calculation with proper offset handling
  
  # Get sun attributes
  sun_next_rising: "{{ state_attr('sun.sun', 'next_rising') }}"
  sun_next_setting: "{{ state_attr('sun.sun', 'next_setting') }}"
  sun_elevation: "{{ state_attr('sun.sun', 'elevation') | float(0) }}"
  
  # Calculate today's actual sunrise (not next sunrise)
  sunrise_today: >-
    {% set next_rising = sun_next_rising %}
    {% if next_rising %}
      {% set next_rising_time = as_timestamp(next_rising) %}
      {% set now_time = now().timestamp() %}
      {% set today_start = as_timestamp(today_at('00:00')) %}
      {% set today_end = as_timestamp(today_at('23:59:59')) %}
      
      {# If next_rising is tomorrow, calculate today's sunrise by subtracting 24 hours #}
      {% if next_rising_time > today_end %}
        {% set today_sunrise = next_rising_time - 86400 %}
      {% else %}
        {# Next rising is still today (we're before sunrise) #}
        {% set today_sunrise = next_rising_time %}
      {% endif %}
      
      {{ today_sunrise }}
    {% else %}
      {# Fallback to 6 AM if no sun data #}
      {{ as_timestamp(today_at('06:00')) }}
    {% endif %}
  
  # Calculate today's actual sunset (not next sunset)
  sunset_today: >-
    {% set next_setting = sun_next_setting %}
    {% if next_setting %}
      {% set next_setting_time = as_timestamp(next_setting) %}
      {% set now_time = now().timestamp() %}
      {% set today_start = as_timestamp(today_at('00:00')) %}
      {% set today_end = as_timestamp(today_at('23:59:59')) %}
      
      {# If next_setting is tomorrow, calculate today's sunset by subtracting 24 hours #}
      {% if next_setting_time > today_end %}
        {% set today_sunset = next_setting_time - 86400 %}
      {% elif next_setting_time < today_start %}
        {# Next setting is yesterday (shouldn't happen but handle it) #}
        {% set today_sunset = next_setting_time + 86400 %}
      {% else %}
        {# Next setting is still today #}
        {% set today_sunset = next_setting_time %}
      {% endif %}
      
      {{ today_sunset }}
    {% else %}
      {# Fallback to 6 PM if no sun data #}
      {{ as_timestamp(today_at('18:00')) }}
    {% endif %}
  
  # Apply offsets to sunrise and sunset (positive = later, negative = earlier)
  sunrise_with_offset: >-
    {% set sunrise_ts = sunrise_today | float %}
    {% set offset_seconds = (sunrise_offset_minutes | float(30)) * 60 %}
    {{ sunrise_ts + offset_seconds }}
  
  sunset_with_offset: >-
    {% set sunset_ts = sunset_today | float %}
    {% set offset_seconds = (sunset_offset_minutes | float(-30)) * 60 %}
    {{ sunset_ts + offset_seconds }}
  
  # Determine if it's currently daytime (between sunrise+offset and sunset+offset)
  is_daytime: >-
    {% set now_ts = now().timestamp() %}
    {% set sunrise_offset_ts = sunrise_with_offset | float %}
    {% set sunset_offset_ts = sunset_with_offset | float %}
    
    {# Handle edge cases #}
    {% if sunrise_offset_ts >= sunset_offset_ts %}
      {# This shouldn't happen unless offsets are extreme #}
      {# Use sun elevation as fallback #}
      {{ sun_elevation > 0 }}
    {% else %}
      {# Normal case: daytime is between sunrise+offset and sunset+offset #}
      {{ sunrise_offset_ts <= now_ts < sunset_offset_ts }}
    {% endif %}
  
  # Alternative method using sun elevation as validation
  # (Sun is typically above horizon when elevation > -0.833 degrees, accounting for atmospheric refraction)
  is_sun_up: "{{ sun_elevation > -0.833 }}"
  
  # Double-check daytime calculation with sun elevation for reliability
  # If there's a major discrepancy, trust the sun elevation
  is_daytime_verified: >-
    {% set now_ts = now().timestamp() %}
    {% set sunrise_offset_ts = sunrise_with_offset | float %}
    {% set sunset_offset_ts = sunset_with_offset | float %}
    {% set time_based_daytime = is_daytime %}
    {% set elevation_based_daytime = is_sun_up %}
    
    {# If both agree, we're good #}
    {% if time_based_daytime == elevation_based_daytime %}
      {{ time_based_daytime }}
    {# If they disagree, check if we're near sunrise/sunset (within 60 minutes) #}
    {% elif (now_ts - sunrise_offset_ts) | abs < 3600 or (now_ts - sunset_offset_ts) | abs < 3600 %}
      {# Near transition time, trust the time-based calculation with offsets #}
      {{ time_based_daytime }}
    {% else %}
      {# Not near transition, something might be wrong, trust sun elevation #}
      {{ elevation_based_daytime }}
    {% endif %}
  
  # Use the verified daytime value for the rest of the automation
  is_daytime_final: "{{ is_daytime_verified }}"
  
  # Check if anyone is home (via device trackers)
  someone_home: >-
    {% if daytime_control_mode != 'block_when_away' or not has_presence_trackers %}
      {{ true }}
    {% else %}
      {% set home_devices = expand(presence_trackers) | selectattr('state', 'eq', 'home') | list %}
      {{ home_devices | count > 0 }}
    {% endif %}
  
  # NEW v3.8.2: Unified daytime control logic
  # Away mode active (nobody home AND daytime AND mode set to block_when_away)
  away_mode_active: >-
    {{ daytime_control_mode == 'block_when_away' and has_presence_trackers and not someone_home and is_daytime_final }}
  
  # No daytime lights mode active
  no_daytime_lights_active: >-
    {{ daytime_control_mode == 'always_block' and is_daytime_final }}
  
  # Should prevent automatic turn ON (but still allow OFF)
  prevent_auto_on: >-
    {{ away_mode_active or no_daytime_lights_active }}
  
  # Primary control entity (for state checking and basic control)
  primary_control_entity: >-
    {% if control_mode == 'lights_only' %}
      {% if has_lights %}
        {{ light_entities[0] }}
      {% else %}
        none
      {% endif %}
    {% elif control_mode == 'switch_and_lights' %}
      {% if has_lights %}
        {{ light_entities[0] }}
      {% elif has_switch %}
        {{ light_switch }}
      {% else %}
        none
      {% endif %}
    {% else %}
      {% if has_switch %}
        {{ light_switch }}
      {% else %}
        none
      {% endif %}
    {% endif %}
  
  # Helper entity names (forced to lowercase for Home Assistant compatibility)
  automation_active_helper: "input_boolean.{{ room_name | lower }}_automation_active"
  manual_override_helper: "input_boolean.{{ room_name | lower }}_manual_override"
  light_auto_on_helper: "input_boolean.{{ room_name | lower }}_light_auto_on"
  last_automation_action_helper: "input_datetime.{{ room_name | lower }}_last_automation_action"
  occupancy_state_helper: "input_boolean.{{ room_name | lower }}_occupancy_state"
  illuminance_history_helper: "input_text.{{ room_name | lower }}_illuminance_history"
  
  # Determine effective mmWave sensor
  mmwave_sensor: >-
    {% if presence_mmwave_sensor and presence_mmwave_sensor != '' %}
      {{ presence_mmwave_sensor }}
    {% else %}
      {{ presence_pir_sensor }}
    {% endif %}
  
  # Cache entity states for performance (with recovery)
  pir_state: >-
    {% set state = states(presence_pir_sensor) %}
    {% if state in ['unknown', 'unavailable', None, ''] %}
      off
    {% else %}
      {{ state }}
    {% endif %}
  
  mmwave_state: >-
    {% set state = states(mmwave_sensor) %}
    {% if state in ['unknown', 'unavailable', None, ''] %}
      off
    {% else %}
      {{ state }}
    {% endif %}
  
  illuminance_state: >-
    {% set state = states(illuminance_sensor) %}
    {% if state in ['unknown', 'unavailable', None, ''] %}
      50
    {% else %}
      {{ state }}
    {% endif %}
  
  bed_state: >-
    {% if has_bed_sensor %}
      {% set state = states(bed_occupied_helper) %}
      {% if state in ['unknown', 'unavailable', None, ''] %}
        off
      {% else %}
        {{ state }}
      {% endif %}
    {% else %}
      off
    {% endif %}
  
  # Timestamps for state change tracking (moved up for availability)
  current_time: "{{ now().timestamp() }}"
  
  # Primary control state
  primary_state: >-
    {% if primary_control_entity != 'none' %}
      {% set state = states(primary_control_entity) %}
      {% if state in ['unknown', 'unavailable', None, ''] %}
        off
      {% else %}
        {{ state }}
      {% endif %}
    {% else %}
      off
    {% endif %}
  
  # Light states (checking all entities)
  lights_on: >-
    {% if control_mode == 'switch_only' %}
      {% if has_switch %}
        {{ states(light_switch) == 'on' }}
      {% else %}
        {{ false }}
      {% endif %}
    {% else %}
      {% if has_lights %}
        {% set lights_that_are_on = expand(light_entities) | selectattr('state', 'eq', 'on') | list %}
        {{ lights_that_are_on | count > 0 }}
      {% else %}
        {{ false }}
      {% endif %}
    {% endif %}
  
  # Basic state validations - check for valid states (return booleans)
  pir_valid: >-
    {{ pir_state not in ['unknown', 'unavailable', None, ''] }}
  mmwave_valid: >-
    {{ mmwave_state not in ['unknown', 'unavailable', None, ''] }}
  primary_valid: >-
    {{ primary_control_entity != 'none' and primary_state not in ['unknown', 'unavailable', None, ''] }}
  illuminance_valid: >-
    {{ illuminance_state not in ['unknown', 'unavailable', None, ''] }}
  bed_valid: >-
    {{ bed_state not in ['unknown', 'unavailable', None, ''] and has_bed_sensor }}
  
  # Core state evaluations  
  pir_active: >-
    {{ pir_valid and pir_state == 'on' }}
  mmwave_active: >-
    {{ mmwave_valid and mmwave_state == 'on' }}
  
  # Room presence - someone physically in the room (PIR or mmWave detecting them)
  someone_present: >-
    {{ pir_active or mmwave_active }}
  
  # SIMPLIFIED v3.8.6: Simple bed occupancy without complex delay tracking
  bed_occupied_raw: "{{ bed_valid and bed_state == 'on' }}"
  
  # Final bed occupied state considering guest mode
  bed_occupied: >-
    {% if not has_bed_sensor %}
      {{ false }}
    {% elif enable_guest_mode and guest_ignore_bed %}
      {{ false }}
    {% else %}
      {{ bed_occupied_raw }}
    {% endif %}
  
  # Illuminance with averaging
  illuminance_raw: >-
    {% if illuminance_valid %}
      {{ illuminance_state | float(50) }}
    {% else %}
      50
    {% endif %}
  
  illuminance_history_raw: >-
    {% if states[illuminance_history_helper] %}
      {% set history = states(illuminance_history_helper) %}
      {% if history in ['unknown', 'unavailable', '', None] %}
        []
      {% else %}
        {{ history }}
      {% endif %}
    {% else %}
      []
    {% endif %}

  # Smart illuminance averaging with spike AND drop detection
  illuminance: >-
    {% if not enable_illuminance_averaging %}
      {{ illuminance_raw }}
    {% else %}
      {% if illuminance_history_raw == '[]' or illuminance_history_raw == [] %}
        {{ illuminance_raw }}
      {% else %}
        {% set history_str = illuminance_history_raw | string %}
        {% if history_str.startswith('[') and history_str.endswith(']') %}
          {% set values = history_str[1:-1].split(',') | select | map('float', 0) | list %}
          
          {% if values | length > 0 %}
            {% set last_avg = (values | sum) / (values | length) %}
            {% set change_ratio = illuminance_raw / last_avg if last_avg > 0 else 1 %}
            
            {# Detect both drops AND spikes #}
            {% if change_ratio < 0.3 and last_avg > 20 %}
              {# Major drop detected - likely lights turned off #}
              {{ illuminance_raw }}
            {% elif change_ratio > 5 and illuminance_raw > 500 %}
              {# Major spike detected - likely flash/lightning #}
              {{ last_avg | round(1) }}
            {% else %}
              {# Remove outliers in both directions #}
              {% set filtered_values = [] %}
              {% for val in values[-4:] %}
                {% set val_ratio = val / illuminance_raw if illuminance_raw > 0 else 999 %}
                {% if 0.2 < val_ratio < 5 or (illuminance_raw < 20 and val < 50) %}
                  {% set filtered_values = filtered_values + [val] %}
                {% endif %}
              {% endfor %}
              
              {% set all_values = filtered_values + [illuminance_raw | float] %}
              {{ (all_values | sum) / (all_values | length) | round(1) }}
            {% endif %}
          {% else %}
            {{ illuminance_raw }}
          {% endif %}
        {% else %}
          {{ illuminance_raw }}
        {% endif %}
      {% endif %}
    {% endif %}
  
  # Light level thresholds
  is_dark: "{{ illuminance < dark_threshold }}"
  is_bright: "{{ illuminance >= bright_threshold }}"
  is_extremely_dark: "{{ illuminance < extremely_dark_threshold }}"
  in_middle_range: "{{ dark_threshold <= illuminance < bright_threshold }}"
  
  # Threshold validation and warnings
  thresholds_valid: "{{ dark_threshold < bright_threshold }}"
  threshold_gap: "{{ bright_threshold - dark_threshold }}"
  threshold_gap_warning: "{{ threshold_gap < 5 }}"
  threshold_gap_critical: "{{ threshold_gap < 2 }}"
  
  # Helper states with validation
  manual_override: >-
    {% if states[manual_override_helper] %}
      {{ is_state(manual_override_helper, 'on') }}
    {% else %}
      {{ false }}
    {% endif %}
  
  automation_active: >-
    {% if states[automation_active_helper] %}
      {{ is_state(automation_active_helper, 'on') }}
    {% else %}
      {{ false }}
    {% endif %}
  
  light_was_auto_on: >-
    {% if states[light_auto_on_helper] %}
      {{ is_state(light_auto_on_helper, 'on') }}
    {% else %}
      {{ false }}
    {% endif %}
  
  primary_changed_time: >-
    {% if primary_control_entity != 'none' and states[primary_control_entity] %}
      {% if states[primary_control_entity].last_changed %}
        {{ as_timestamp(states[primary_control_entity].last_changed, current_time) }}
      {% else %}
        {{ current_time }}
      {% endif %}
    {% else %}
      {{ current_time }}
    {% endif %}
  
  override_changed_time: >-
    {% if states[manual_override_helper] %}
      {% if states[manual_override_helper].last_changed %}
        {{ as_timestamp(states[manual_override_helper].last_changed, current_time) }}
      {% else %}
        {{ current_time }}
      {% endif %}
    {% else %}
      {{ current_time }}
    {% endif %}
  
  occupancy_changed_time: >-
    {% if states[occupancy_state_helper] %}
      {% if states[occupancy_state_helper].last_changed %}
        {{ as_timestamp(states[occupancy_state_helper].last_changed, current_time) }}
      {% else %}
        {{ current_time }}
      {% endif %}
    {% else %}
      {{ current_time }}
    {% endif %}
  
  last_automation_time: >-
    {% if states[last_automation_action_helper] and states[last_automation_action_helper].state %}
      {% set last_action = states(last_automation_action_helper) %}
      {% if last_action not in ['unknown', 'unavailable', '', None] %}
        {# The datetime helper stores as ISO format string #}
        {% set action_time = as_timestamp(last_action, 0) %}
        {{ action_time }}
      {% else %}
        0
      {% endif %}
    {% else %}
      0
    {% endif %}
  
  # Time calculations
  primary_changed_seconds_ago: "{{ (current_time - primary_changed_time) | round(1) }}"
  override_active_minutes: "{{ ((current_time - override_changed_time) / 60) | round(1) }}"
  room_vacant_minutes: >-
    {% if someone_present %}
      0
    {% else %}
      {{ ((current_time - occupancy_changed_time) / 60) | round(1) }}
    {% endif %}
  time_since_last_automation: "{{ (current_time - last_automation_time) | round(1) }}"
  
  # Check if automation_active is stale (stuck on)
  automation_active_stale: >-
    {% if automation_active %}
      {% if states[automation_active_helper] and states[automation_active_helper].last_changed %}
        {% set active_time = as_timestamp(states[automation_active_helper].last_changed, 0) %}
        {% if active_time > 0 %}
          {{ (current_time - active_time) > 3 }}
        {% else %}
          {{ true }}
        {% endif %}
      {% else %}
        {{ true }}
      {% endif %}
    {% else %}
      {{ false }}
    {% endif %}
  
  # Recent change detection
  primary_recently_changed: "{{ primary_changed_seconds_ago < 2 }}"
  override_recently_set: "{{ manual_override and (current_time - override_changed_time) < 5 }}"
  
  # Enhanced manual change detection
  is_manual_change: >-
    {% if trigger.platform != 'state' %}
      {{ false }}
    {% elif control_mode == 'switch_only' and trigger.entity_id == light_switch %}
      {% if automation_active and not automation_active_stale and time_since_last_automation < 1 %}
        {{ false }}
      {% else %}
        {{ true }}
      {% endif %}
    {% elif control_mode != 'switch_only' and trigger.entity_id in light_entities %}
      {% if automation_active and not automation_active_stale and time_since_last_automation < 1 %}
        {{ false }}
      {% else %}
        {{ true }}
      {% endif %}
    {% else %}
      {{ false }}
    {% endif %}
  
  # Trigger analysis
  is_primary_trigger: >-
    {% if control_mode == 'switch_only' %}
      {{ trigger.platform == 'state' and trigger.entity_id == light_switch }}
    {% else %}
      {{ trigger.platform == 'state' and trigger.entity_id in light_entities }}
    {% endif %}
  is_pir_trigger: "{{ trigger.platform == 'state' and trigger.entity_id == presence_pir_sensor }}"
  is_mmwave_trigger: "{{ trigger.platform == 'state' and trigger.entity_id == mmwave_sensor }}"
  is_illuminance_trigger: "{{ trigger.platform == 'state' and trigger.entity_id == illuminance_sensor }}"
  is_periodic_trigger: "{{ trigger.platform == 'time_pattern' }}"
  is_sun_trigger: "{{ trigger.platform == 'state' and trigger.entity_id == 'sun.sun' }}"
  # FIXED v3.8.6: Bed trigger detected via state change check
  is_bed_trigger: >-
    {% if has_bed_sensor and is_periodic_trigger %}
      {% if states[bed_occupied_helper] %}
        {% set last_change = as_timestamp(states[bed_occupied_helper].last_changed, 0) %}
        {% if last_change > 0 %}
          {{ (now().timestamp() - last_change) < 5 }}
        {% else %}
          {{ false }}
        {% endif %}
      {% else %}
        {{ false }}
      {% endif %}
    {% else %}
      {{ false }}
    {% endif %}
  
  user_turned_on: "{{ is_primary_trigger and trigger.to_state.state == 'on' and trigger.from_state.state == 'off' }}"
  user_turned_off: "{{ is_primary_trigger and trigger.to_state.state == 'off' and trigger.from_state.state == 'on' }}"
  
  # Automation intent with daytime control - SIMPLIFIED for bed sensor
  auto_would_turn_on: >-
    {% if prevent_auto_on %}
      {{ false }}
    {% elif bed_occupied and not (enable_guest_mode and guest_ignore_bed) %}
      {{ false }}
    {% else %}
      {{ is_dark and someone_present }}
    {% endif %}
  
  # Turn OFF is always allowed (energy saving) - includes bed occupancy
  auto_would_turn_off: >-
    {% if not someone_present and lights_on %}
      {{ true }}
    {% elif has_bed_sensor and turn_off_when_bed_occupied and bed_occupied and lights_on and not (enable_guest_mode and guest_ignore_bed) %}
      {{ true }}
    {% else %}
      {{ false }}
    {% endif %}
  
  # Guest mode adjustments
  effective_vacancy_multiplier: >-
    {{ (vacancy_timeout_multiplier * guest_vacancy_multiplier) if enable_guest_mode else vacancy_timeout_multiplier }}
  
  effective_override_hours: >-
    {{ (override_timeout_hours * guest_override_multiplier) if enable_guest_mode else override_timeout_hours }}
  
  effective_vacancy_clear_minutes: >-
    {{ (vacancy_clear_minutes * guest_vacancy_multiplier) if enable_guest_mode else vacancy_clear_minutes }}
  
  # Override timeout logic with guest mode and presence respect
  override_timeout_exceeded: >-
    {% if manual_override and (override_active_minutes / 60) > effective_override_hours %}
      {% if override_respect_presence %}
        {{ not someone_present or lights_on }}
      {% else %}
        {{ true }}
      {% endif %}
    {% else %}
      {{ false }}
    {% endif %}

  vacancy_clear_triggered: >-
    {{ manual_override and override_behavior == 'vacancy_clear' and room_vacant_minutes >= effective_vacancy_clear_minutes }}

  override_should_clear: "{{ override_timeout_exceeded or vacancy_clear_triggered }}"

  # Determine clear reason for logging
  override_clear_reason: >-
    {% if override_timeout_exceeded and override_respect_presence and not someone_present %}
      "timeout while vacant ({{ effective_override_hours }}h{{ ' guest mode' if enable_guest_mode else '' }})"
    {% elif override_timeout_exceeded and override_respect_presence and lights_on %}
      "timeout with lights already on ({{ effective_override_hours }}h{{ ' guest mode' if enable_guest_mode else '' }})"
    {% elif override_timeout_exceeded and not override_respect_presence %}
      "timeout ({{ effective_override_hours }}h{{ ' guest mode' if enable_guest_mode else '' }})"
    {% elif vacancy_clear_triggered %}
      "vacancy ({{ room_vacant_minutes | int }}min{{ ' guest mode' if enable_guest_mode else '' }})"
    {% else %}
      "unknown"
    {% endif %}
  
  # Light capabilities (check first available light entity)
  first_light_entity: >-
    {% if has_lights %}
      {{ light_entities[0] }}
    {% elif has_switch and light_switch.startswith('light.') %}
      {{ light_switch }}
    {% else %}
      none
    {% endif %}
  
  light_is_dimmable: >-
    {% if first_light_entity != 'none' %}
      {{ state_attr(first_light_entity, 'supported_features') is not none }}
    {% else %}
      {{ false }}
    {% endif %}
  
  light_supports_color_temp: >-
    {% if first_light_entity != 'none' %}
      {{ state_attr(first_light_entity, 'min_color_temp_kelvin') is not none }}
    {% else %}
      {{ false }}
    {% endif %}
  
  # Adaptive brightness calculation
  adaptive_brightness: >-
    {% if not enable_adaptive_brightness or not light_is_dimmable %}
      100
    {% else %}
      {% set hour = now().hour %}
      {% set night_hours = hour >= 22 or hour < 6 %}
      {% set evening_hours = hour >= 20 and hour < 22 %}
      {% set morning_hours = hour >= 6 and hour < 8 %}
      
      {% if enable_guest_mode %}
        {% if is_extremely_dark %}
          {{ 50 if night_hours else 90 }}
        {% elif is_dark %}
          {% if night_hours %}
            60
          {% elif morning_hours or evening_hours %}
            80
          {% else %}
            100
          {% endif %}
        {% else %}
          100
        {% endif %}
      {% else %}
        {% if is_extremely_dark %}
          {{ 30 if night_hours else 80 }}
        {% elif is_dark %}
          {% if night_hours %}
            40
          {% elif morning_hours or evening_hours %}
            70
          {% else %}
            90
          {% endif %}
        {% else %}
          100
        {% endif %}
      {% endif %}
    {% endif %}
  
  # Adaptive color temperature calculation
  adaptive_color_temp: >-
    {% if not enable_color_temperature or not light_supports_color_temp %}
      0
    {% else %}
      {% set hour = now().hour %}
      {% set progress = 0 %}
      {% if 6 <= hour < 9 %}
        {% set progress = (hour - 6) / 3 %}
      {% elif 9 <= hour < 17 %}
        {% set progress = 1 %}
      {% elif 17 <= hour < 21 %}
        {% set progress = 1 - ((hour - 17) / 4) %}
      {% else %}
        {% set progress = 0 %}
      {% endif %}
      {% set temp_range = day_color_temp - night_color_temp %}
      {% set temp = night_color_temp + (temp_range * progress) %}
      {{ temp | int }}
    {% endif %}
  
  # Transition time calculations
  effective_fade_on_time: >-
    {% if enable_fade_on %}
      {{ fade_on_time }}
    {% else %}
      0
    {% endif %}
  
  effective_fade_off_time: >-
    {% if enable_fade_off %}
      {{ fade_off_time }}
    {% else %}
      0
    {% endif %}
  
  # Sensor latency calculation with guest mode
  sensor_off_latency_seconds: >-
    {% if sensor_off_latency_entity and sensor_off_latency_entity != '' %}
      {% set latency = states(sensor_off_latency_entity) | float(0) %}
      {% set base_latency = latency if latency > 0 else fixed_latency_seconds %}
    {% else %}
      {% set base_latency = fixed_latency_seconds %}
    {% endif %}
    {{ (base_latency * 1.5) if enable_guest_mode else base_latency }}
  
  # Vacancy timeout calculation
  vacancy_timeout_minutes: >-
    {% set timeout = (sensor_off_latency_seconds * effective_vacancy_multiplier) / 60 %}
    {{ [timeout | round(0, 'ceil'), 1] | max | int }}

# Triggers - Universal handling with optional bed sensor
trigger:
  # State changes
  - platform: state
    entity_id: !input presence_pir_sensor
    id: pir_change
  
  - platform: state
    entity_id: !input presence_mmwave_sensor
    id: mmwave_change
    
  - platform: state
    entity_id: !input illuminance_sensor
    id: illuminance_change
    
  - platform: state
    entity_id: !input light_switch
    id: switch_change
    
  - platform: state
    entity_id: !input light_entities
    id: light_change
    
  - platform: state
    entity_id: sun.sun
    id: sun_change
    
  # NOTE: Bed sensor handled via periodic check to avoid empty entity errors
  # Periodic checks (handles bed sensor and other monitoring)
  - platform: time_pattern
    seconds: "/5"  # Check every 5 seconds for responsive bed delays
    id: periodic_check
  
  # Check for updates periodically
  
  # Check for updates periodically
  - platform: time
    at: "10:00:00"
    id: update_check
  
  - platform: state
    entity_id: sensor.universal_lighting_updates
    id: update_sensor_changed

# Conditions
condition:
  # Skip if triggered by empty/invalid entity
  - condition: template
    value_template: >-
      {% if trigger.entity_id is defined %}
        {% if trigger.entity_id == '' or trigger.entity_id == None %}
          {{ false }}
        {% else %}
          {{ true }}
        {% endif %}
      {% else %}
        {{ true }}
      {% endif %}
  
  # Skip if no control entities are configured
  - condition: template
    value_template: >-
      {{ primary_control_entity != 'none' }}
  
  # Don't trigger on attribute-only changes
  - condition: template
    value_template: >-
      {{ trigger.id == 'periodic_check' or trigger.id == 'update_check' or trigger.id == 'update_sensor_changed' or
         (trigger.from_state is defined and trigger.to_state is defined and
          trigger.from_state.state != trigger.to_state.state) }}

# Actions
action:
  # Performance tracking start
  - variables:
      action_start_time: "{{ now().timestamp() }}"
  
  # Version update check (only if enabled)
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {{ enable_update_check and 
                 (trigger.id == 'update_check' or trigger.id == 'update_sensor_changed') }}
        sequence:
          # Check if sensor exists, if not show setup instructions
          - choose:
              # Sensor missing - show setup instructions
              - conditions:
                  - condition: template
                    value_template: "{{ not sensor_exists }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      title: "ðŸ’¡ Enable Update Notifications - {{ room_name }}"
                      message: >-
                        To get update notifications for your lighting automation:
                        
                        **Add this to `configuration.yaml`:**
                        ```yaml
                        sensor:
                          - platform: rest
                            name: "Universal Lighting Updates"
                            resource: https://api.github.com/repos/Chris971991/universal-smart-light-automation/releases/latest
                            value_template: "{{ '{{ value_json.tag_name | default(\'unknown\') }}' }}"
                            scan_interval: 86400
                        ```
                        
                        Then restart Home Assistant. This message will only appear once per day.
                      notification_id: "lighting_update_setup_{{ room_name | lower | replace(' ', '_') }}"
              
              # Update available - show update notification  
              - conditions:
                  - condition: template
                    value_template: "{{ sensor_exists and update_available }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      title: "ðŸŽ‰ Lighting Update Available - {{ room_name }}"
                      message: >-
                        **New version {{ latest_version }} is available!**
                        You have version {{ blueprint_version }}
                        
                        **{{ release_name }}**
                        
                        **How to Update:**
                        1. Go to **Settings** â†’ **Automations & Scenes** â†’ **Blueprints**
                        2. Find "Universal Smart Presence Lighting Control"
                        3. Click **â‹®** â†’ **Re-import Blueprint**
                        4. Your automations will keep working!
                        
                        [ðŸ“– View What's New]({{ release_url }})
                      notification_id: "lighting_update_available_{{ room_name | lower | replace(' ', '_') }}"
                  
                  # Clear the setup notification if it exists
                  - service: persistent_notification.dismiss
                    data:
                      notification_id: "lighting_update_setup_{{ room_name | lower | replace(' ', '_') }}"
                    continue_on_error: true
              
              # Up to date - clear any notifications
              - conditions:
                  - condition: template
                    value_template: "{{ sensor_exists and not update_available }}"
                sequence:
                  - service: persistent_notification.dismiss
                    data:
                      notification_id: "lighting_update_available_{{ room_name | lower | replace(' ', '_') }}"
                    continue_on_error: true
                  - service: persistent_notification.dismiss
                    data:
                      notification_id: "lighting_update_setup_{{ room_name | lower | replace(' ', '_') }}"
                    continue_on_error: true
  
  # Skip the update check triggers for normal automation
  - condition: template
    value_template: "{{ trigger.id not in ['update_check', 'update_sensor_changed'] }}"
  
  # NEW v3.8.2: Check for missing trackers when required
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ trackers_missing and is_periodic_trigger }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "{{ room_name }} - Configuration Warning"
              message: >-
                âš ï¸ "Block When Away" mode requires device trackers!
                
                You've selected "Block When Away" but haven't configured any device trackers.
                The automation will work but won't prevent daytime lighting when away.
                
                To fix: Add device trackers in the automation configuration.
              notification_id: "{{ room_name }}_tracker_warning"
  
  # State recovery - clear stale helpers
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {% set helpers_stale = false %}
              {% if states[automation_active_helper] and states[automation_active_helper].last_changed %}
                {% set age_hours = (current_time - as_timestamp(states[automation_active_helper].last_changed, current_time)) / 3600 %}
                {% if age_hours > 24 %}
                  {% set helpers_stale = true %}
                {% endif %}
              {% endif %}
              {{ helpers_stale }}
        sequence:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ automation_active_helper }}"
            continue_on_error: true
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ manual_override_helper }}"
            continue_on_error: true
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: warning
                  message: "[{{ room_name | upper }}] State recovery: Reset stale helpers after >24h"
  
  # Clear stale automation_active flag FIRST
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ automation_active_stale }}"
        sequence:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ automation_active_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "[{{ room_name | upper }}] Cleared stale automation_active flag"
  
  # Threshold validation warnings (with conditional logging)
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ threshold_gap_critical and is_periodic_trigger }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "{{ room_name }} - Critical Threshold Warning"
              message: >-
                âš ï¸ Your dark/bright thresholds are critically close ({{ threshold_gap }} lux gap)!
                
                Current settings:
                â€¢ Dark: {{ dark_threshold }} lux
                â€¢ Bright: {{ bright_threshold }} lux
                
                This may cause rapid on/off cycling. Recommended minimum gap: 10 lux
                
                Suggested values:
                â€¢ Dark: {{ dark_threshold }} lux
                â€¢ Bright: {{ [dark_threshold + 20, 50] | max }} lux
              notification_id: "{{ room_name }}_threshold_warning"
      - conditions:
          - condition: template
            value_template: "{{ threshold_gap_warning and not threshold_gap_critical and is_periodic_trigger }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: warning
                  message: >-
                    [{{ room_name | upper }}] Threshold gap warning: {{ threshold_gap }} lux
                    Consider increasing gap to at least 10 lux for stability
  
  # Validate helper entities exist (ALWAYS show errors)
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {% set missing = [] %}
              {% if not states[automation_active_helper] %}
                {% set missing = missing + [automation_active_helper] %}
              {% endif %}
              {% if not states[manual_override_helper] %}
                {% set missing = missing + [manual_override_helper] %}
              {% endif %}
              {% if not states[light_auto_on_helper] %}
                {% set missing = missing + [light_auto_on_helper] %}
              {% endif %}
              {% if not states[last_automation_action_helper] %}
                {% set missing = missing + [last_automation_action_helper] %}
              {% endif %}
              {% if not states[occupancy_state_helper] %}
                {% set missing = missing + [occupancy_state_helper] %}
              {% endif %}
              {% if not states[illuminance_history_helper] %}
                {% set missing = missing + [illuminance_history_helper] %}
              {% endif %}
              {{ missing | length > 0 }}
        sequence:
          # ERROR LOG - ALWAYS SHOWN
          - service: system_log.write
            data:
              level: error
              message: >-
                [{{ room_name | upper }}] CRITICAL: Missing required helper entities!
                {% for helper in missing %}
                - {{ helper }}
                {% endfor %}
          - service: persistent_notification.create
            data:
              title: "{{ room_name }} Lighting Automation Error"
              message: >-
                Missing required helper entities! Please create:
                {% for helper in missing %}
                - {{ helper }}
                {% endfor %}
                
                Remember: All entity IDs must be lowercase!
              notification_id: "{{ room_name }}_lighting_helper_error"
          - stop: "Missing required helper entities"
  
  # Validate control configuration (ALWAYS show errors)
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {% if control_mode == 'switch_only' and not has_switch %}
                {{ true }}
              {% elif control_mode == 'lights_only' and not has_lights %}
                {{ true }}
              {% elif control_mode == 'switch_and_lights' and not has_switch and not has_lights %}
                {{ true }}
              {% else %}
                {{ false }}
              {% endif %}
        sequence:
          # ERROR LOG - ALWAYS SHOWN
          - service: system_log.write
            data:
              level: error
              message: >-
                [{{ room_name | upper }}] CRITICAL: Invalid control configuration!
                Control mode: {{ control_mode }}
                {% if control_mode == 'switch_only' %}
                - No switch entity selected
                {% elif control_mode == 'lights_only' %}
                - No light entities selected
                {% elif control_mode == 'switch_and_lights' %}
                - Neither switch nor light entities selected
                {% endif %}
          - service: persistent_notification.create
            data:
              title: "{{ room_name }} Lighting Automation Error"
              message: >-
                Invalid configuration for control mode "{{ control_mode }}":
                {% if control_mode == 'switch_only' %}
                - No switch entity selected
                {% elif control_mode == 'lights_only' %}
                - No light entities selected
                {% elif control_mode == 'switch_and_lights' %}
                - Neither switch nor light entities selected
                {% endif %}
              notification_id: "{{ room_name }}_lighting_config_error"
          - stop: "Invalid control configuration"
  
  # Clear any previous error notifications
  - service: persistent_notification.dismiss
    data:
      notification_id: "{{ room_name }}_lighting_helper_error"
    continue_on_error: true
  - service: persistent_notification.dismiss
    data:
      notification_id: "{{ room_name }}_lighting_config_error"
    continue_on_error: true
  - service: persistent_notification.dismiss
    data:
      notification_id: "{{ room_name }}_tracker_warning"
    continue_on_error: true
  
  # Update illuminance history
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ is_illuminance_trigger and enable_illuminance_averaging }}"
        sequence:
          - service: input_text.set_value
            target:
              entity_id: "{{ illuminance_history_helper }}"
            data:
              value: >-
                {% if illuminance_history_raw == '[]' or illuminance_history_raw == [] %}
                  [{{ illuminance_raw }}]
                {% else %}
                  {% set history_str = illuminance_history_raw | string %}
                  {% if history_str.startswith('[') and history_str.endswith(']') %}
                    {% set values = history_str[1:-1].split(',') | select | map('float', 0) | list %}
                    
                    {% if values | length > 0 %}
                      {% set last_avg = (values | sum) / (values | length) %}
                      {% set change_ratio = illuminance_raw / last_avg if last_avg > 0 else 1 %}
                      
                      {% if change_ratio < 0.3 and last_avg > 20 %}
                        [{{ illuminance_raw }}]
                      {% elif change_ratio > 5 and illuminance_raw > 500 %}
                        [{{ values[-5:] | join(',') }}]
                      {% else %}
                        {% set filtered_values = [] %}
                        {% for val in values[-4:] %}
                          {% set val_ratio = val / illuminance_raw if illuminance_raw > 0 else 999 %}
                          {% if 0.2 < val_ratio < 5 or (illuminance_raw < 20 and val < 50) %}
                            {% set filtered_values = filtered_values + [val] %}
                          {% endif %}
                        {% endfor %}
                        
                        {% set new_values = filtered_values[-4:] + [illuminance_raw | float] %}
                        [{{ new_values | join(',') }}]
                      {% endif %}
                    {% else %}
                      [{{ illuminance_raw }}]
                    {% endif %}
                  {% else %}
                    [{{ illuminance_raw }}]
                  {% endif %}
                {% endif %}
  
  # SIMPLIFIED v3.8.6: Debug with simple bed state info
  - if:
      - condition: template
        value_template: "{{ enable_debug_logs }}"
    then:
      - service: system_log.write
        data:
          level: warning
          message: >-
            â”Œâ”€ {{ room_name | upper }} AUTOMATION START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            â”‚ Trigger: {{ trigger.id }} ({{ trigger.description | default('manual') }})
            â”‚ Control Mode: {{ control_mode }}
            â”‚ Lights On: {{ 'YES' if lights_on else 'NO' }}
            â”‚ Room Presence: {{ 'YES' if someone_present else 'NO' }} (PIR={{ pir_state }}/{{ pir_active }}, mmWave={{ mmwave_state }}/{{ mmwave_active }})
            â”‚ Home Presence: {{ 'SOMEONE HOME' if someone_home else 'NOBODY HOME' }} {% if has_presence_trackers %}({{ expand(presence_trackers) | selectattr('state', 'eq', 'home') | map(attribute='name') | list | join(', ') or 'all away' }}){% endif %}
            â”‚ Daytime: {{ 'YES' if is_daytime_final else 'NO' }} (sun elevation: {{ sun_elevation }}Â°)
            â”‚ Sunrise: {{ (sunrise_with_offset | timestamp_custom('%H:%M', true)) }} (+{{ sunrise_offset_minutes }}min)
            â”‚ Sunset: {{ (sunset_with_offset | timestamp_custom('%H:%M', true)) }} ({{ sunset_offset_minutes }}min)
            â”‚ Daytime Control: {{ daytime_control_mode | upper | replace('_', ' ') }}
            â”‚ Prevent Auto-ON: {{ 'YES' if prevent_auto_on else 'NO' }} {% if prevent_auto_on %}({{ 'nobody home' if away_mode_active else 'daytime block' }}){% endif %}
            â”‚ Illuminance: {{ illuminance }}lux (dark<{{ dark_threshold }}, brightâ‰¥{{ bright_threshold }})
            â”‚ Override: {{ 'ACTIVE' if manual_override else 'INACTIVE' }}
            â”‚ Bed: {% if has_bed_sensor %}{{ 'OCCUPIED' if bed_occupied_raw else 'EMPTY' }}{% if is_bed_trigger %} (CHANGED <5s ago){% endif %}{% else %}NO SENSOR{% endif %}
            â”‚ Guest Mode: {{ 'ENABLED' if enable_guest_mode else 'DISABLED' }}
            â”‚ Auto would turn ON: {{ auto_would_turn_on }}
            â”‚ Auto would turn OFF: {{ auto_would_turn_off }}
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  # Skip if automation is already active
  - condition: template
    value_template: >-
      {% if not is_primary_trigger and automation_active and not automation_active_stale %}
        {% if states[automation_active_helper] and states[automation_active_helper].last_changed %}
          {% set active_time = as_timestamp(states[automation_active_helper].last_changed, 0) %}
          {% if active_time > 0 %}
            {{ (current_time - active_time) > 0.5 }}
          {% else %}
            {{ true }}
          {% endif %}
        {% else %}
          {{ true }}
        {% endif %}
      {% else %}
        {{ true }}
      {% endif %}
  
  # Update occupancy state helper if changed (with conditional logging)
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {{ states[occupancy_state_helper] and 
                 someone_present != is_state(occupancy_state_helper, 'on') }}
        sequence:
          - service: "input_boolean.turn_{{ 'on' if someone_present else 'off' }}"
            target:
              entity_id: "{{ occupancy_state_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "[{{ room_name | upper }}] Occupancy state updated: {{ 'OCCUPIED' if someone_present else 'VACANT' }}"
  
  # Debug manual change detection (with conditional logging)
  - if:
      - condition: template
        value_template: "{{ enable_debug_logs and is_primary_trigger }}"
    then:
      - service: system_log.write
        data:
          level: warning
          message: >-
            [{{ room_name | upper }}] Manual change detection:
            â”‚ is_manual_change: {{ is_manual_change }}
            â”‚ automation_active: {{ automation_active }}
            â”‚ time_since_last_automation: {{ time_since_last_automation }}

  # Override clearing logic (with conditional logging)
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ manual_override and override_should_clear }}"
        sequence:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ manual_override_helper }}"
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ light_auto_on_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: warning
                  message: >-
                    â”Œâ”€ {{ room_name | upper }} OVERRIDE CLEARED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â”‚ Reason: {{ override_clear_reason }}
                    â”‚ Was active for: {{ override_active_minutes }} minutes
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          - delay:
              milliseconds: 100
          - service: automation.trigger
            target:
              entity_id: "{{ this.entity_id }}"
            data:
              skip_condition: false
          - stop: "Override cleared - retriggering automation"
  
  # Check for active manual override (with conditional logging)
  - if:
      - condition: template
        value_template: >-
          {{ manual_override and not is_primary_trigger and 
            not (control_mode == 'switch_and_lights' and trigger.entity_id == light_switch) }}
    then:
      - if:
          - condition: template
            value_template: "{{ enable_debug_logs }}"
        then:
          - service: system_log.write
            data:
              level: info
              message: >-
                [{{ room_name | upper }}] Manual override active - skipping automation
                â”‚ Would have: {{ 'turned ON' if (is_dark and someone_present and not bed_occupied and not prevent_auto_on and not lights_on) else 'turned OFF' if (auto_would_turn_off and lights_on) else 'done nothing' }}
      - stop: "Manual override active"
  
  # Main automation logic
  - choose:
      # Handle manual light changes (with conditional logging)
      - conditions:
          - condition: template
            value_template: "{{ is_manual_change }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: warning
                  message: >-
                    â”Œâ”€ {{ room_name | upper }} MANUAL CHANGE DETECTED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â”‚ Action: Turned {{ 'ON' if user_turned_on else 'OFF' }}
                    â”‚ Entity: {{ trigger.entity_id }}
                    â”‚ Auto would: {{ 'turn ON' if auto_would_turn_on else 'turn OFF' if auto_would_turn_off else 'do nothing (prevented by daytime control)' if prevent_auto_on else 'do nothing' }}
                    â”‚ Illuminance: {{ illuminance }}lux
                    â”‚ Presence: {{ 'YES' if someone_present else 'NO' }}
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          
          # Determine if override should be set or cleared
          - choose:
              # Set override - user action conflicts with automation
              - conditions:
                  - condition: template
                    value_template: >-
                      {{ (user_turned_on and (not auto_would_turn_on or prevent_auto_on)) or 
                         (user_turned_off and auto_would_turn_on and not prevent_auto_on) }}
                sequence:
                  - service: input_boolean.turn_on
                    target:
                      entity_id: "{{ manual_override_helper }}"
                  - delay:
                      milliseconds: 100
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: >-
                            [{{ room_name | upper }}] Manual override SET
                            â”‚ Reason: Conflicts with automation
              
              # Clear override - user action matches automation intent
              - conditions:
                  - condition: template
                    value_template: >-
                      {% if has_bed_sensor and bed_occupied and not (enable_guest_mode and guest_ignore_bed) %}
                        {{ false }}
                      {% else %}
                        {{ (user_turned_on and auto_would_turn_on and not prevent_auto_on) or 
                           (user_turned_off and auto_would_turn_off) }}
                      {% endif %}
                sequence:
                  - service: input_boolean.turn_off
                    target:
                      entity_id: "{{ manual_override_helper }}"
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: "[{{ room_name | upper }}] Override cleared - action matches automation"
              
              # Clear override - user turned off in bright room
              - conditions:
                  - condition: template
                    value_template: "{{ user_turned_off and is_bright and someone_present }}"
                sequence:
                  - service: input_boolean.turn_off
                    target:
                      entity_id: "{{ manual_override_helper }}"
                  - delay:
                      milliseconds: 100
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: "[{{ room_name | upper }}] Override cleared - lights off in bright room"
              
              # Default case - set override for other manual changes
              - conditions:
                  - condition: template
                    value_template: >-
                      {% set auto_on_recent = false %}
                      {% if is_state(light_auto_on_helper, 'on') and user_turned_on %}
                        {% if states[light_auto_on_helper] and states[light_auto_on_helper].last_changed %}
                          {% set auto_on_changed = as_timestamp(states[light_auto_on_helper].last_changed, 0) %}
                          {% if auto_on_changed > 0 %}
                            {% set age = current_time - auto_on_changed %}
                            {% set auto_on_recent = age < 5 %}
                          {% endif %}
                        {% endif %}
                      {% endif %}
                      
                      {% set bed_auto_off = false %}
                      {% if user_turned_off and turn_off_when_bed_occupied and bed_occupied and not (enable_guest_mode and guest_ignore_bed) %}
                        {% set bed_auto_off = true %}
                      {% endif %}
                      
                      {% set threshold_gap = bright_threshold - dark_threshold %}
                      
                      {% set wants_dark_while_present = false %}
                      {% if not bed_auto_off %}
                        {% set wants_dark_while_present = user_turned_off and someone_present and not is_bright %}
                      {% endif %}
                      
                      {% set wants_light_when_not_dark = user_turned_on and not is_dark and someone_present %}
                      
                      {% set fighting_automation = false %}
                      {% if not bed_auto_off %}
                        {% set fighting_automation = user_turned_off and light_was_auto_on and someone_present %}
                      {% endif %}
                      
                      {% set extreme_override = false %}
                      {% if not bed_auto_off %}
                        {% set extreme_override = user_turned_off and is_extremely_dark and someone_present %}
                      {% endif %}
                      
                      {% set narrow_threshold = threshold_gap <= 10 %}
                      {% set middle_range_override = false %}
                      {% if not bed_auto_off %}
                        {% set middle_range_override = narrow_threshold and in_middle_range and someone_present %}
                      {% endif %}
                      
                      {% set bed_override = false %}
                      {% if has_bed_sensor and bed_occupied and not (enable_guest_mode and guest_ignore_bed) %}
                        {% set bed_override = user_turned_on %}
                      {% endif %}
                      
                      {{ not auto_on_recent and not bed_auto_off and (
                        wants_dark_while_present or 
                        wants_light_when_not_dark or 
                        fighting_automation or 
                        extreme_override or
                        middle_range_override or
                        bed_override
                      ) }}
                sequence:
                  - service: input_boolean.turn_on
                    target:
                      entity_id: "{{ manual_override_helper }}"
                  - delay:
                      milliseconds: 100
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: >-
                            [{{ room_name | upper }}] Manual override SET
                            â”‚ Reason: User preference
          
          # Clear auto-on flag
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ light_auto_on_helper }}"
          
          # Stop if override was set
          - condition: template
            value_template: "{{ not manual_override }}"
      
      # Automatic light control (with conditional logging)
      - conditions:
          - condition: template
            value_template: "{{ not manual_override and not primary_recently_changed }}"
        sequence:
          # Double-check override state
          - condition: template
            value_template: "{{ is_state(manual_override_helper, 'off') }}"
          
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: >-
                    [{{ room_name | upper }}] Automatic control evaluating...
                    â”‚ Someone present: {{ someone_present }}
                    â”‚ Lights on: {{ lights_on }}
                    â”‚ Would turn ON: {{ auto_would_turn_on }}
                    â”‚ Would turn OFF: {{ auto_would_turn_off }}
                    â”‚ Prevent auto-ON: {{ prevent_auto_on }}
                    â”‚ Bed occupied: {{ bed_occupied }}
                    â”‚ Should: {{ 'turn ON' if (auto_would_turn_on and not lights_on and not prevent_auto_on) else 'turn OFF' if (auto_would_turn_off and lights_on) else 'prevent auto-ON' if (prevent_auto_on and is_dark and someone_present and not lights_on) else 'do nothing' }}
          
          - choose:
              # Turn lights ON (with simple bed delay)
              - conditions:
                  - condition: template
                    value_template: "{{ auto_would_turn_on and not lights_on and not prevent_auto_on }}"
                sequence:
                  # If this is triggered by getting out of bed, wait the exit delay
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ is_bed_trigger and not bed_occupied_raw and has_bed_sensor }}"
                        sequence:
                          - delay:
                              seconds: "{{ bed_exit_delay_seconds }}"
                          # Re-check conditions after delay
                          - condition: template
                            value_template: "{{ is_dark and someone_present and states(bed_occupied_helper) == 'off' and not manual_override }}"
                  
                  # Set automation active
                  - service: input_boolean.turn_on
                    target:
                      entity_id: "{{ automation_active_helper }}"
                  
                  # Record action time
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ last_automation_action_helper }}"
                    data:
                      datetime: "{{ now() }}"
                  
                  # Final safety check
                  - condition: template
                    value_template: >-
                      {{ is_dark and someone_present and not bed_occupied and 
                         not lights_on and is_state(manual_override_helper, 'off') and
                         not prevent_auto_on }}
                  
                  # Turn on lights based on control mode
                  - choose:
                      # Smart lights only or switch+lights mode
                      - conditions:
                          - condition: template
                            value_template: "{{ control_mode != 'switch_only' and has_lights }}"
                        sequence:
                          # Turn on smart lights with features
                          - service: light.turn_on
                            target:
                              entity_id: "{{ light_entities }}"
                            data: >-
                              {% set data = {} %}
                              {% if enable_adaptive_brightness and light_is_dimmable %}
                                {% set data = dict(data, **{'brightness_pct': adaptive_brightness}) %}
                              {% endif %}
                              {% if enable_color_temperature and light_supports_color_temp and adaptive_color_temp > 0 %}
                                {% set data = dict(data, **{'kelvin': adaptive_color_temp}) %}
                              {% endif %}
                              {% if effective_fade_on_time > 0 %}
                                {% set data = dict(data, **{'transition': effective_fade_on_time}) %}
                              {% endif %}
                              {{ data }}
                      
                      # Switch only mode
                      - conditions:
                          - condition: template
                            value_template: "{{ control_mode == 'switch_only' and has_switch }}"
                        sequence:
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ light_switch.startswith('light.') and light_is_dimmable }}"
                                sequence:
                                  - service: light.turn_on
                                    target:
                                      entity_id: "{{ light_switch }}"
                                    data: >-
                                      {% set data = {} %}
                                      {% if enable_adaptive_brightness %}
                                        {% set data = dict(data, **{'brightness_pct': adaptive_brightness}) %}
                                      {% endif %}
                                      {% if enable_color_temperature and light_supports_color_temp and adaptive_color_temp > 0 %}
                                        {% set data = dict(data, **{'kelvin': adaptive_color_temp}) %}
                                      {% endif %}
                                      {% if effective_fade_on_time > 0 %}
                                        {% set data = dict(data, **{'transition': effective_fade_on_time}) %}
                                      {% endif %}
                                      {{ data }}
                            default:
                              - service: homeassistant.turn_on
                                target:
                                  entity_id: "{{ light_switch }}"
                  
                  # Set auto-on flag
                  - service: input_boolean.turn_on
                    target:
                      entity_id: "{{ light_auto_on_helper }}"
                  
                  # Clear automation active with improved delay
                  - delay:
                      seconds: "{{ [effective_fade_on_time, 0.5] | max }}"
                  - service: input_boolean.turn_off
                    target:
                      entity_id: "{{ automation_active_helper }}"
                  
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: warning
                          message: >-
                            â”Œâ”€ {{ room_name | upper }} LIGHTS TURNED ON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                            â”‚ Control Mode: {{ control_mode }}
                            â”‚ Brightness: {{ adaptive_brightness }}%
                            â”‚ Color Temp: {{ adaptive_color_temp }}K
                            â”‚ Guest Mode: {{ 'YES' if enable_guest_mode else 'NO' }}
                            â”‚ Bed Exit Delay: {{ bed_exit_delay_seconds }}s{% if is_bed_trigger and not bed_occupied_raw %} (APPLIED Â±5s){% endif %}
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              
              # Turn lights OFF (with simple bed delay)
              - conditions:
                  - condition: template
                    value_template: "{{ auto_would_turn_off and lights_on }}"
                sequence:
                  # Handle bed-triggered OFF with delay
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: >-
                              {{ has_bed_sensor and 
                                 turn_off_when_bed_occupied and 
                                 is_bed_trigger and 
                                 trigger.to_state.state == 'on' and
                                 not (enable_guest_mode and guest_ignore_bed) }}
                        sequence:
                          # Wait the entry delay
                          - delay:
                              seconds: "{{ bed_entry_delay_seconds }}"
                          
                          # Verify ALL conditions still valid after delay
                          - condition: template
                            value_template: >-
                              {{ states(bed_occupied_helper) == 'on' and
                                 lights_on and
                                 not manual_override and
                                 turn_off_when_bed_occupied }}
                          
                          # Log if debug enabled
                          - if:
                              - condition: template
                                value_template: "{{ enable_debug_logs }}"
                            then:
                              - service: system_log.write
                                data:
                                  level: warning
                                  message: "[{{ room_name | upper }}] Turning off lights - bed occupied for {{ bed_entry_delay_seconds }}s"
                  
                  # Set automation active
                  - service: input_boolean.turn_on
                    target:
                      entity_id: "{{ automation_active_helper }}"
                  
                  # Record action time
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ last_automation_action_helper }}"
                    data:
                      datetime: "{{ now() }}"
                  
                  # Final safety check
                  - condition: template
                    value_template: >-
                      {% set vacant_trigger = not someone_present %}
                      {% set bed_trigger = has_bed_sensor and turn_off_when_bed_occupied and bed_occupied and not (enable_guest_mode and guest_ignore_bed) %}
                      {{ (vacant_trigger or bed_trigger) and lights_on }}
                  
                  # Turn off lights based on control mode
                  - choose:
                      # Smart lights only or switch+lights mode - turn off lights directly
                      - conditions:
                          - condition: template
                            value_template: "{{ control_mode != 'switch_only' and has_lights }}"
                        sequence:
                          - service: light.turn_off
                            target:
                              entity_id: "{{ light_entities }}"
                            data: >-
                              {% if effective_fade_off_time > 0 %}
                                {'transition': {{ effective_fade_off_time }}}
                              {% else %}
                                {}
                              {% endif %}
                      
                      # Switch only mode - turn off switch
                      - conditions:
                          - condition: template
                            value_template: "{{ control_mode == 'switch_only' and has_switch }}"
                        sequence:
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ light_switch.startswith('light.') and effective_fade_off_time > 0 }}"
                                sequence:
                                  - service: light.turn_off
                                    target:
                                      entity_id: "{{ light_switch }}"
                                    data:
                                      transition: "{{ effective_fade_off_time }}"
                            default:
                              - service: homeassistant.turn_off
                                target:
                                  entity_id: "{{ light_switch }}"
                  
                  # Clear auto-on flag
                  - service: input_boolean.turn_off
                    target:
                      entity_id: "{{ light_auto_on_helper }}"
                  
                  # Clear automation active with improved delay
                  - delay:
                      seconds: "{{ [effective_fade_off_time, 0.5] | max }}"
                  - service: input_boolean.turn_off
                    target:
                      entity_id: "{{ automation_active_helper }}"
                  
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: warning
                          message: >-
                            â”Œâ”€ {{ room_name | upper }} LIGHTS TURNED OFF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                            â”‚ Control Mode: {{ control_mode }}
                            â”‚ Reason: {% if turn_off_when_bed_occupied and bed_occupied and not (enable_guest_mode and guest_ignore_bed) %}Bed occupied{% else %}Room vacant{% endif %}
                            â”‚ Fade Off: {{ effective_fade_off_time }}s
                            â”‚ Bed Entry Delay: {{ bed_entry_delay_seconds }}s{% if is_bed_trigger and bed_occupied_raw %} (APPLIED Â±5s){% endif %}
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              
              # Log when prevented from turning on (but not when lights already on) - with conditional logging
              - conditions:
                  - condition: template
                    value_template: "{{ prevent_auto_on and is_dark and someone_present and not bed_occupied and not lights_on }}"
                sequence:
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: >-
                            [{{ room_name | upper }}] AUTO-ON PREVENTED
                            â”‚ Reason: {% if away_mode_active %}Block when away (nobody home during daytime){% elif no_daytime_lights_active %}Always block daytime mode{% else %}Unknown{% endif %}
                            â”‚ Would have turned on: Dark ({{ illuminance }}lux) and occupied
  
  # Decision summary with performance metrics (with conditional logging)
  - if:
      - condition: template
        value_template: "{{ enable_debug_logs }}"
    then:
      - service: system_log.write
        data:
          level: warning
          message: >-
            [{{ room_name | upper }}] DECISION SUMMARY
            â”œâ”€ Room Presence: {{ 'YES' if someone_present else 'NO' }}
            â”œâ”€ Home Presence: {{ 'SOMEONE HOME' if someone_home else 'NOBODY HOME' }}
            â”œâ”€ Daytime: {{ 'YES' if is_daytime_final else 'NO' }}
            â”œâ”€ Light Level: {{ illuminance }}lux ({{ 'Dark' if is_dark else 'Bright' if is_bright else 'Medium' }})
            â”œâ”€ Daytime Prevention: {{ 'ACTIVE' if prevent_auto_on else 'INACTIVE' }}
            â”œâ”€ Override: {{ 'ACTIVE' if manual_override else 'INACTIVE' }}
            â”œâ”€ Bed Status: {% if has_bed_sensor %}{{ 'OCCUPIED' if bed_occupied else 'EMPTY' }}{% else %}N/A{% endif %}
            â”œâ”€ Action Taken: {% if lights_on != (expand(light_entities) | selectattr('state', 'eq', 'on') | list | count > 0 if has_lights else is_state(light_switch, 'on') if has_switch else false) %}Lights {{ 'turned ON' if (expand(light_entities) | selectattr('state', 'eq', 'on') | list | count > 0 if has_lights else is_state(light_switch, 'on') if has_switch else false) else 'turned OFF' }}{% elif prevent_auto_on %}Auto-ON prevented{% else %}No change{% endif %}
            â”œâ”€ Execution Time: {{ ((now().timestamp() - action_start_time) * 1000) | round(1) }}ms
            â””â”€ Performance: {% if ((now().timestamp() - start_time) * 1000) < 100 %}âš¡ Excellent{% elif ((now().timestamp() - start_time) * 1000) < 500 %}âœ” Good{% else %}âš ï¸ Slow{% endif %}

mode: restart  # Changed from 'queued' to 'restart' for better delay handling
max: 2
max_exceeded: warning